<html>
    <head>
        <title>Multi-Armed Bandits System Usage</title>
        <style>
            ul {list-style: none;}
        </style>
    </head>
    <body>
        <h1>Multi-Armed Bandits System Usage</h1>
        <div id="intro">
            <p>
                This file documents how to use the system for running multi-armed bandits experiments.<br>
                <b>Note:</b> Everything stated in this documentation is correct with relation to the system 
                and code at the time the documentation was written. The author makes no guarantee that 
                future users making updates to the system will update the documentation to correspond with 
                changes they have made.
            </p>
        </div>
        <div id="table-of-contents">
            <h2>Table of Contents</h2>
            <ul>

            </ul>
        </div>
        <div id="contents">
            <div id="quick_guides">
                <h2>Getting Started</h2>
                <p>

                </p>
                <div id="experimenting">
                    <h3>Running Experiments</h3>
                    <p>

                    </p>
                    <ol>
                        <li>Create an input file</li>
                        <li>Run the experiments</li>
                        <li>Compile and plot results</li>
                    </ol>
                </div>
                <div id="adding_application">
                    <h3>Adding a New Application</h3>
                    <p>

                    </p>
                    <ol>
                        <li>Create a parameter file.</li>
                        <li>Create an implementation.</li>
                        <li>Configure the path setup.</li>
                        <li>(Optional, but recommended) Register the application in the namespace sub-system.</li>
                    </ol>
                </div>
                <div id="adding_algorithm">
                    <h3>Adding a New Algorithm</h3>
                    <p>

                    </p>
                    <ol>
                        <li>Create a parameter file.</li>
                        <li>Create an implementation.</li>
                        <li>Configure the path setup.</li>
                        <li>(Optional, but recommended) Register the algorithm in the namespace sub-system.</li>
                    </ol>
                </div>
            </div>
            <div id="editing_code">
                <h2>Creating and Editing Code</h2>
                <p>
                    This section goes over the details of how to create different types of code files, some notes on important steps 
                    in the process of editing existing code, and details about working with some key classes and files.<br>
                    Before beginning, it is important to note that, for any code, import statements should be written relative to 
                    the top level Code directory. So, for example, a file wishing to import the file Code/Utilities/program_vars.py as a module
                    would write 'import Utilities.program_vars', regardless of where the importing file is located.
                </p>
                <div id="editing_existing_code">
                    <h3>Editing Existing Code</h3>
                    <p>
                        If you intend to make changes to existing code that could, in any way, cause some other part of the code to 
                        stop working, it is important that you first create and check out a new branch on Git to enact your changes on.
                        Once you have finished writing and testing your changes, you can merge your branch back into the one you were previously
                        working on and, if you wish, you can delete the branch you performed your changes on after merging.<br>
                        Additionally, if extensive changes are being made to the codebase, such that users may wish to revisit the current version
                        at some point in time, a named tag should be created on Git for the current version, so that the current version can easily be found
                        and reloaded.
                    </p>
                </div>
                <div id="main_entry">
                    <h3>Main Entry Points</h3>
                    <p>
                        If you are writing a file that contains a 'main' entry point, it is vital that this file is called using the Code directory 
                        as the working directory. It is recommended that the file be located within the main Code directory to facilitate this, 
                        but it is not strictly necessary. 
                    </p>
                </div>
                <div id="using_paramset">
                    <h3>Working With Parameter Accessors</h3>
                    <p>
                        There are two classes used for accessing parameter values within Applications and Algorithms: BaseParamSet and ParamSet.<br>
                        <b>BaseParamSet</b> wraps the parameter values for a single section: the application, the algorithm, or the global variables. It is 
                        an object of this type that is passed into the 'createInstance' method defined in implementation files for Applications and 
                        Algorithms. It is also an object of this type that is returned to the main method when running experiments to retrieve global 
                        variables with.<br>
                        In order to retrieve the value of a parameter, you simply call the 'get' method, using a string with the name of the parameter to retrieve 
                        as the argument.<br>
                        In order to add a parameter value or set the value of a parameter, you call the 'setAttr' method, which takes two arguments in this order: a string with the 
                        name of the parameter, and the value to assign.<br>
                        The class also contains a 'reset' method that is used in conjunction with Python multiprocessing. This needs to be used because the class stores 
                        python modules internally, but Python multiprocessing internally uses pickling in order to send objects to other processes. Python modules cannot be pickled.<br>
                        <b>ParamSet</b> wraps three instances of BaseParamSet (global parameters, application parameters, and algorithm parameters) as well as having the possibility of
                        storing a dictionary with parameters determined using information from both the application and algorithm (joint parameters). An instance of
                        ParamSet is what is passed to the pset argument in the Algorithm 'run' function, it is also what gets passed into the parameters argument of functions that validate
                        all experiment parts together (within parameter files), should you choose to implement any. Additionally, the ParamSet of an experiment is included in the 
                        pickled results file produced for that experiment. <br>
                        ParamSet contains the same functions as BaseParamSet with one key difference. It also has a few important new functions.<br>
                        The differenc is that the functions 'get' and 'setAttr' expect a number in front of the other attributes 
                        indicating the the section that is being worked with (globals, application, algorithm, or joint). These numbers should be imported from Utilities.program_vars 
                        to ensure they remain correct if the values of those variables ever change.<br>
                        The new functions are:<br>
                        <b>getApp</b>: This returns the name of the application.
                        <b>getAlg</b>: This returns the name of the algorithm.
                        <b>getPath(timestamp, randId)</b>: This takes the timestamp and the random id to 
                        identify the run (these are not always used, depending on the configuration, but 
                        they must always be provided) and returns a string representing most of the file path
                        used to create the file. All you need to do to complete the file path is to 
                        concatenate the base file name (eg: results.pkl) to the end of the returned string.
                        The underlying functions also ensure that any directories along the path exist.
                    </p>
                </div>
                <div id="parameter_files">
                    <h3>Writing a Parameter File</h3>
                    <p>
                        Writing a parameter file for an application or algorithm parameter file should 
                        ideally be done in parallel to implementing the application or algorithm. Parameter 
                        files for applications should go into the folder 'Code/parameters/application_params' 
                        and should be named '&ltapplication name&gt_params.py'. For example: im_params.py 
                        is the parameter file for the application im. Parameter 
                        files for algorithms should go into the folder 'Code/parameters/algorithm_params' 
                        and should be named '&ltalgorithm name&gt_params.py'. For example: etcg_params.py 
                        is the parameter file for the algorithm etcg.<br>
                        The parameter file should define a variable and a default value 
                        (even if that default value is none) for every variable in the application or algorithm
                        that is only written to once (or is an input parameter) and is not dependent on 
                        any parameters from the other side (for instance, seed_set_size, for algorithms). 
                        Additionally, it is important that any parameters whose values might be used in the 
                        file path have a string form (for the value) that contains only characters that are 
                        valid in file paths and that the string form does not contain the basic separator 
                        string. If the values do not meet this criteria (or if you just want some different
                        format), you will want to add parameters just for holding the string value with the 
                        new format. For instance, in the im application, the list of values available to choose 
                        from for the 'tv' weighting method could potentially be changed and used in the 
                        file path, so we format the string for it by taking the string form of each value in the list of options
                        separating them with hyphens.<br>
                        Parameter files also need to implement a function called 'validateSolo' that accepts
                        a single argument. This argument will be a dictionary specifying the configuration
                        of the application or algorithm, the dictionary is pulled from the input file. 
                        To access just the parameters, you need to lookup the item "params" within the 
                        given argument. So: parameters = data["params"]. There are two purposes to this function:
                        <ol>
                            <li>Validate the parameters passed in. Here you should do any validation needed:
                                make sure that the values are the correct datatypes, make sure the given values 
                                are within accepted ranges, if two parameters need to have values that work together 
                                in some way, make sure that they do, etc. Remember that not all parameters may 
                                be in the input file, and those that aren't will use the default values defined 
                                in the file. If an error is detected, an exception should be raised with an 
                                appropriate error message.
                            </li>
                            <li>
                                This is an opportunity to calculate and store the value of parameters whose value is 
                                determined using other parameters, this value should be added to the parameter 
                                dictionary. This also includes parameters who have a separate variable representing
                                their string form.
                            </li>
                        </ol>
                        Parameter files are also allowed to optionally define a boolean variable called 'doFullCheck'
                        and a function called 'validateFull' which receives, in order, a ParamSet object, 
                        an Application object, and an Algorithm object. (Note that 'validateFull' will not be 
                        run unless 'doFullCheck' is defined and is set to true.) This function allows validation to 
                        be done on a whole experiment together. Meaning that if, for instance, an application 
                        can only be paired with specific algorithms for some reason, that can be checked here.<br>
                        This function can also be used to set parameters that can only be determined using values 
                        from both the Application and the Algorithm, or parameters used by one that requires 
                        values from the other to determine. For instance, the total number of options available 
                        for the agent to choose between. Another example would be that, in the old code, 
                        there was an algorithm called IMLinUCB that needed an data object called 'df_feats'. 
                        This object was calculated using information from the application. Therefore, this 
                        would be calculated in the 'validateFull' function.
                        These parameters/variables should be set into the 'joint' section of
                        the ParamSet.
                    </p>
                </div>
                <div id="implementing_applications">
                    <h3>Implementing an Application</h3>
                    <p>
                        Writing an implementation for an application should ideally be done in parallel 
                        to writing a parameter file for the application. To implement an application, 
                        there should be a file named &ltapplication name&gt.py located somewhere under the 
                        folder 'Code/application', it doesn't matter where. For instance at the time of 
                        writing, im.py is located under 'Code/application/im' while toylin.py is located 
                        under 'Code/application'. This file should contain a function called 'createInstance'
                        which takes a BaseParamSet as an argument and returns an object of a class that 
                        extends the Application class.<br>
                        You will also need to write a class extending the Application class. Typically 
                        this is done in the same file (&ltapplication name&gt.py) as the createInstance 
                        function, and the createInstance function simply calls the constructor.<br>
                        In order to implement the Application, you will need to import the Application class: 
                        'from application.application import Application' and you will need to create a 
                        class definition that extends Application: 'class MyApp(Application):'. Your class 
                        will need to define and implement the following functions:
                        <ol>
                            <li><h4>getReward(self, choices, spontaneous_prob=None)</h4>
                                This function should return the reward received from choosing the arm selection 
                                indicated by the 'choices', argument. The function should expect those choices
                                to be the same items given by the 'listOptions' function. If listOptions 
                                returns a list of objects, then the choices will be a list containing some of 
                                those same objects.<br> 
                                To maintain compatibility with older 
                                code within the im application, it also can accept a list of probabilities 
                                for each node that the node gets spontaneously influenced. Your application 
                                must include this parameter in the function signature, but if the parameter 
                                is not relevant to the application, it can be ignored. (Note that the 
                                default value is None because lists and objects should not be used as 
                                default values, they do not reset between function calls if changed.)
                            </li>
                            <li><h4>getOptionCount(self)</h4>
                                This function should return the number of options/arms that are available 
                                for a learning agent to choose from.
                            </li>
                            <li><h4>listOptions(self)</h4>
                                This function should return a list of what options/arms are available for the 
                                agent to choose from. These listed options should be a distinct way of identifying 
                                the options internally, because the Application should expect the Algorithm 
                                to use the exact items in this list to identify which options are chosen in the 
                                getReward function.
                            </li>
                            <li><h4>refresh(self)</h4>
                                This function is intended to allow Applications to re-initialize any items 
                                that were initialized using random values. For example, 
                                in the im application, if the 'rn' weighting method is used, this allows 
                                the network weights to be re-initialized with new random values. 
                                The function is called before the start of an experimental run, after 
                                the random seed for the run has been set.
                                This function exists because, when doing multiple runs of the same experiment, 
                                the same Application object is used.<br>
                                Another possible use for this function is to reset any internal state the 
                                Application might keep that it doesn't want being kept between runs.<br>
                                If you don't have any randomized parameters or internal state to reset, 
                                you can implement this as an empty function:<pre>
    def refresh(self):
        ...
                                </pre>
                                <b>Important Note:</b> This function will only be called if the global parameter 
                                'refresh' is set to true. At the time of writing, this is the default.
                            </li>
                        </ol>
                        If you want or need to create additional  code files in order to implement the 
                        algorithm, you are welcome to do so, though it is recommended to create a folder 
                        within Code/application in order to keep the related files together.
                    </p>
                </div>
                <div id="implementing_algorithms">
                    <h3>Implementing an Algorithm</h3>
                    <p>
                        Writing an implementation for an algorithm should ideally be done in parallel 
                        to writing a parameter file for the algorithm. To implement an algorithm, 
                        there should be a file named &ltalgorithm name&gt.py located somewhere under the 
                        folder 'Code/alogorithm', it doesn't matter where. For example, at the time of 
                        writing, the algorithm implementation etcg.py is located under 'Code/algorithm/adaptive', 
                        but you could also have an algorithm implementation directly under 'Code/algorithm' or 
                        anywhere else that falls below 'Code/algorithm'. This file should contain a function 
                        called 'createInstance'
                        which takes a BaseParamSet as an argument and returns an object of a class that 
                        extends the Algorithm class.<br>
                        You will also need to write a class extending the Algorithm class. Typically 
                        this is done in the same file (&ltalgorithm name&gt.py) as the createInstance 
                        function, and the createInstance function simply calls the constructor.<br>
                        In order to implement the Algorithm, you will need to import the Algorithm class: 
                        'from algorithm.algorithm import Algorithm' and you will need to create a 
                        class definition that extends Algorithm: 'class MyAlg(Algorithm):'. Your class 
                        will need to define and implement the following functions:
                        <ol>
                            <li><h4>run(self, app, pset, timestamp, randId)</h4>
                                This function should run the Algorithm on the given Application (app) using 
                                the given ParamSet object (pset) to look up parameters. It should return a 
                                single object containing the results that it wants saved to file for use 
                                in compilation and plotting. For example,
                                most Algorithms at the time of writing return a Python dictionary containing 
                                fields named 'best_seed_sets' and 'rewards'. A dictionary containing the 
                                ParamSet (in a field named 'params') and the returned results (in a field 
                                named 'results') will be saved to a pickle file with a base name of 'results.pkl'.
                                The timestamp and random id provided are the timestamp and random id that will be 
                                used (if relevant) when creating the results file. If the Algorithm creates files 
                                of its own, it may choose to use the timestamp and random id provided, or generate 
                                new ones using the getTimestamp and getRandomId functions in 
                                'Code/Utilities/name_generation.py'. The main body of the file path should be generated 
                                by using the getPath(timestamp, randomId) function of the ParamSet, the path is completed by 
                                concatenating the base file name to the returned path.
                            </li>
                            <li><h4>refresh(self)</h4>
                                This function is intended to allow Algorithms to re-initialize any items 
                                that were initialized using random values. There are not currently 
                                (at the time of writing) any Algorithms 
                                that do this, but, using an Application example, 
                                in the im application, if the 'rn' weighting method is used, this allows 
                                the network weights to be re-initialized with new random values. 
                                The function is called before the start of an experimental run, after 
                                the random seed for the run has been set.
                                This function exists because, when doing multiple runs of the same experiment, 
                                the same Algorithm object is used.<br>
                                Another possible use for this function is to reset any internal state the 
                                Algorithm might keep that it doesn't want being kept between runs.<br>
                                If you don't have any randomized parameters or internal state to reset, 
                                you can implement this as an empty function:<pre>
    def refresh(self):
        ...
                                </pre>
                                <b>Important Note:</b> This function will only be called if the global parameter 
                                'refresh' is set to true. At the time of writing, this is the default.
                            </li>
                        </ol>
                        If you want or need to create additional  code files in order to implement the 
                        algorithm, you are welcome to do so, though it is recommended to create a folder 
                        within Code/application in order to keep the related files together.
                    </p>
                </div>
                <div id="experiment_results">
                    <h3>Retrieving Experiment Results</h3>
                    <p>
                        When you want to access the result data from an experiment, you must first load 
                        the pickle file created from running the experiment. The data saved will have 
                        two fields:
                        <ol>
                            <li><b>params</b>: This contains the ParamSet object used in the experiment.
                            It can be used to retrieve any of the parameter values.
                            </li>
                            <li><b>results</b>: This contains the object returned from the Algorithm's 
                            run function.
                            </li>
                        </ol>
                    </p>
                </div>
            </div>
            <div id="paths">
                <h2>Configuring and Changing Experiment Result File Paths</h2>
                <p>
                    This section gives information on how the file paths of the result files produced 
                    while running experiments are structured. It also provides information on how to 
                    configure the file paths and how to obtain information on the current configurations.
                </p>
                <div id="path_design">
                    <h3>Experiment Result File Path Structure</h3>
                    <p>
                        This section goes over how the paths for result files are structured and the files used to configure the individual sections.
                    </p>
                    <div id="path_components">
                        <h4>Components of Experiment Result File Paths</h4>
                        <p>
                            There are four main components that a file path for an experiment should contain:
                            <ol>
                                <li>
                                    Values pertaining to the application used in the experiment.<br> 
                                    This includes identifying 
                                    the application being used and the values of all parameters currently under test for the 
                                    application.<br>
                                    This will be take the form of a path element of the form 'app-&ltapplication name&gt' (for instance: app-im) 
                                    followed by the value used for each of the application's parameters under test. Each of these elements must be 
                                    separated. In our system, we allow the ability to choose after which elements the path should be broken into folders.
                                    A path separator is used to separate elements that are broken into different folders. To separate elements that are 
                                    not broken into different folders, we use the basic separator string (See <a href="#basic_separator">Basic Separator</a>).
                                    At the time of writing, the basic separator string is the underscore character.
                                    <br>
                                    <b>For example:</b><br>
                                    Suppose we are using the application 'im' with the parameters 'weighting_method' and 'uniform_weight' in that order. If the 
                                    weighting_method is 'un' and the uniform_weight is '0.3', and if we decide that we want path separators after the 
                                    application identifier and nowhere else, then the resulting path segment is:<br>
                                    app-im/un_0.3<br>
                                    Note that there is also information we are not currently using indicating that uniform_weight wants to be followed by a basic separator.
                                    So the path segment wants to be app-im/un_0.3_
                                </li>
                                <li>
                                    Values pertaining to the algorithm used in the experiment.<br> 
                                    This includes identifying 
                                    the algorithm being used and the values of all parameters currently under test for the 
                                    algorithm.<br>
                                    This will be take the form of a path element of the form 'alg-&ltalgorithm name&gt' (for instance: alg-etcg) 
                                    followed by the value used for each of the algorithm's parameters under test. Each of these elements must be 
                                    separated. In our system, we allow the ability to choose after which elements the path should be broken into folders.
                                    A path separator is used to separate elements that are broken into different folders. To separate elements that are 
                                    not broken into different folders, we use the basic separator string (See <a href="#basic_separator">Basic Separator</a>).
                                    At the time of writing, the basic separator string is the underscore character.
                                    <br>
                                    <b>For example:</b><br>
                                    Suppose we are using the algorithm 'etcg' with the parameters 'seed_set_size' and 'time_horizon' in that order. If the 
                                    seed_set_size is 13 and the time_horizon is 20000, and if we decide that we want path separators after the 
                                    time_horizon and nowhere else, then the resulting path segment is:<br>
                                    alg-etcg_13_20000<br>
                                    Note that there is also information we are not currently using indicating that time_horizon wants to be followed by a path separator.
                                    So the path segment wants to be alg-etcg_13_20000/
                                </li>
                                <li>
                                    Values identifying individual experiments.<br>
                                    For our system, this includes timestamps and random IDs. 
                                    These are optional, but using at least one of them allows our system to keep multiple files with the same experimental parameters 
                                    instead of overwriting them. Timestamps are used with a precision level of seconds, which means that they should be used for differentiating 
                                    and ordering different occurrences of running the experimental system, but not for differentiating multiple runs of the same experimental 
                                    setup within the same execution of the experimental system (in other words, not good for differentiating files produced by the same 
                                    call to run_experiment.py). Random IDs are useful for giving files from different runs different file paths, regardless of how simultaneously 
                                    they occur (due to different random seeds), they are not useful for allowing users to intuit which set of experiments a result file was produced 
                                    in, or to find the results from funning a particular set of experiment runs.<br>
                                    In our system, we specify that the order of the elements, if both are used, will be timestamp followed by random ID, in order to maintain the 
                                    sorting properties provided by the timestamp. Further, if both are used, they will be separated by a basic separator string 
                                    (See <a href="#basic_separator">Basic Separator</a>). However, we do allow the ability to customize which elements are used, if any, 
                                    and whether the section should be followed by a path separator or a basic separator. (This information is only used if at least one element 
                                    is used.)<br>
                                    <b>For example:</b><br>
                                    If both elements are in use and we have a timestamp of 2022-05-21-15-04-58 and a random ID of 12345678, the path section is:<br>
                                    2022-05-21-15-04-58_12345678<br>
                                    If a path separator is used afterwards, this becomes:
                                    2022-05-21-15-04-58_12345678/<br>
                                    If a path separator is not used afterwards, this becomes:
                                    2022-05-21-15-04-58_12345678_<br>
                                </li>
                                <li>
                                    The base file name.<br>
                                    This is the end of the file path and it identifies the file itself, rather than the circumstances under which the file was generated. 
                                    This is also the actual name of the file if the last identifying element is followed by a path separator. <br>
                                    <b>For example:</b><br>
                                    results.pkl
                                </li>
                            </ol>
                        </p>
                    </div>
                    <div id="connecting_components">
                        <h4>A Complete File Path</h4>
                        <p>
                            This section goes over how the path components are ordered and how they are connected together, as well as giving a few complete path examples.<br>
                            It is important to note that all paths generated using this system are rooted in the directory indicated by the variable temp_dir in the file 
                            'Code/Utilities/global_names.py'. At the time of writing, this directory is 'Files/Temporary/Created'. <br>
                            The system allows users to specify whether it is values pertaining to applications or values pertaining to algorithms that appear first. The other 
                            appears second. If at least one of them is used, the values identifying individual runs come third, otherwise they are skipped. The base file 
                            name comes last.<br>
                            Before going over how the groups are joined together, let's set up some examples.
                            We are using the application 'im' with the parameters 'weighting_method' and 'uniform_weight' in that order. If the 
                            weighting_method is 'un' and the uniform_weight is '0.3', and if we decide that we want path separators after the 
                            application identifier and nowhere else, then the resulting path segment is:<br>
                            app-im/un_0.3<br>
                            And it wants to be followed by a basic separator (underscore).<br>
                            We are using the algorithm 'etcg' with the parameters 'seed_set_size' and 'time_horizon' in that order. If the 
                            seed_set_size is 13 and the time_horizon is 20000, and if we decide that we want path separators after the 
                            time_horizon and nowhere else, then the resulting path segment is:<br>
                            alg-etcg_13_20000<br>
                            And it wants to be followed by a path separator.<br>
                            We will give examples both with and without information identifying individual experiments.
                            When the information is used, we will have both elements in use and have a timestamp of 
                            2022-05-21-15-04-58 and a random ID of 12345678, the path section is:<br>
                            2022-05-21-15-04-58_12345678<br>
                            We will have this followed by a path separator.<br>
                            Our base file name will be results.pkl.
                            Now for joining the sections together.<br>
                            To join the first and second groups, we use the separator string that is set to follow 
                            the last element of the first group. <br>
                            If applications are first, this makes our example:<br>
                            app-im/un_0.3_alg-etcg_13_20000<br>
                            If algorithms are first, this makes our example:<br>
                            alg-etcg_13_20000/app-im/un_0.3<br>
                            <br>
                            If information identifying individual runs is being used, then it is joined to the second 
                            group using a path separator, regardless of what separator wants to follow the last element of 
                            the second group.<br>
                            With individual run information being used and applications going first, our example becomes:<br>
                            app-im/un_0.3_alg-etcg_13_20000/2022-05-21-15-04-58_12345678<br>
                            With individual run information being used and algorithms going first, our example becomes:<br>
                            alg-etcg_13_20000/app-im/un_0.3/2022-05-21-15-04-58_12345678<br>
                            Finally, the base file name will be joined to whatever section preceeds it 
                            using the string that should follow the last element of the preceeding section. 
                            So:<br>
                            With individual run information being used and applications going first, our example becomes:<br>
                            app-im/un_0.3_alg-etcg_13_20000/2022-05-21-15-04-58_12345678/results.pkl<br>
                            With individual run information being used and algorithms going first, our example becomes:<br>
                            alg-etcg_13_20000/app-im/un_0.3/2022-05-21-15-04-58_12345678/results.pkl<br>
                            With individual run information not being used and applications going first, our example becomes:<br>
                            app-im/un_0.3_alg-etcg_13_20000/results.pkl<br>
                            With individual run information not being used and algorithms going first, our example becomes:<br>
                            alg-etcg_13_20000/app-im/un_0.3_results.pkl<br>
                        </p>
                    </div>
                    <div id="namespace_files">
                        <h4>Path Configuration Files</h4>
                        <p>
                            This section goes over how to manually write the files that set the configuration 
                            of the file paths for experiment results.<br>
                            <b>IMPORTANT NOTE:</b> This should only be done if you are creating a file 
                            for a domain that doesn't have any files or setting up a file containing default 
                            values that were already in use. For example: a configuration file for an 
                            application that doesn't have any files under it yet, a configuration file for an 
                            algorithm that doesn't have any files under it yet, a joint configuration file 
                            for an application-algorithm pair that doesn't have any files under it yet, 
                            or a file to specify the whether application or algorithm parameters come firt 
                            only if no output files at all exist yet.<br><br>

                            If you are trying to change the configuration for a domain that already contains 
                            output files, or simply wish to use the system to incrementally change the 
                            configuration, see <a href="#altering_namespace">Changing Path Configurations</a>.
                        </p>
                        <div id="app_alg_namespace">
                            <h5>Application and Algorithm Configuration Files</h5>
                            <p>
                                A configuration file for an application or algorithm should be a JSON 
                                (See <a href="#json_primer">Primer on JSON Files</a>) file 
                                'Files/Namespace/ApplicationNames/&ltapplication name&gt.json' for applications 
                                and 'Files/Namespace/AlgorithmNames/&ltalgorithm name&gt.json' for algorithms.<br>
                                For instance: Files/Namespace/ApplicationNames/im.json<br>
                                and: Files/Namespace/AlgorithmNames/etcg.json<br>
                                If the necessary folder does not already exist, you will need to create it.
                                The top level object of the file should contain two variables, both of which are 
                                lists of the same length. The first variable is "headers" and the second variable 
                                is "separators". The list of headers should contain strings, the first of which is 
                                "app-&ltapplication name&gt" (eg. "app-im") for applications and 
                                "alg-&ltalgorithm name&gt" (eg. "alg-etcg") for algorithms. The remaining items 
                                in the list of headers are the names of the parameters from the application 
                                or algorithm whose values should be used in the file path, in the order that 
                                they should appear.<br>
                                The "separators" list contains booleans, each corresponding to the 
                                item in the "headers" list that appears at the same index. If the 
                                boolean is true, the corresponding parameter value will be followed 
                                by a path separator in the file path. If the boolean is false, the corresponding parameter 
                                value will be followed by the basic separator string in the file path.<br>
                                An example for the file Files/Namespace/AlgorithmNames/etcg.json might be:<pre>
{
    "headers":["alg-etcg", "time_horizon", "seed_set_size"],
    "separators":[false, true, false]
}
                                </pre>
                            </p>
                        </div>
                        <div id="joint_namespace">
                            <h5>Experiment Identifier (Joint) Configuration Files</h5>
                            <p>
                                A configuration file for the files that fall under a particular application and algorithm should be a JSON 
                                (See <a href="#json_primer">Primer on JSON Files</a>) file 
                                'Files/Namespace/JointNames/&ltapplication name&gt_&ltalgorithm name&gt.json'. <br>
                                For instance: Files/Namespace/JointNames/im_etcg.json<br>
                                If the necessary folder does not already exist, you will need to create it.
                                The top level object should contain three variables, all of which are booleans: 
                                <ul>
                                    <li>
                                        "use_timestamp": If true, a timestamp will be used to identify files.
                                    </li>
                                    <li>"use_randID": If true, a random ID will be used to identify files.</li>
                                    <li>"sep_after": If true, a file separator will appear in the path after the included identifying information. Otherwise 
                                        a basic separater will appear.
                                    </li>
                                </ul>
                            </p>
                        </div>
                        <div id="ordering">
                            <h5>Application-Algorithm Path Parameter Order</h5>
                            <p>
                                The file to control whether application or algorithm parameters appear 
                                first should be a JSON (See <a href="#json_primer">Primer on JSON Files</a>) file 
                                'Files/Namespace/global_name_vars.json'
                                where the top-level object has a single variabel: "app_first". This is 
                                a boolean variable. If it is true, the application parameters appear first.
                                If it is false, the algorithm parameters appear first. If this file does 
                                not exist, the default (at the time of writing) is that the application 
                                parameters appear first.
                            </p>
                        </div>
                    </div>
                </div>
                <div id="config_information">
                    <h3>Current Path Configuration Information</h3>
                    <p>
                        To obtain information on the way paths are currently configured, you will want to use the 
                        interface defined in 'alter_namespace.py'.<br>
                        alter_namespace.py offers the following commands for obtaining information on the current 
                        configurations:<br>
                        <ol>
                            <li>
                                Info: The info command is used to print the current configuration of path 
                                segments for files that fall under a given application or algorithm or the information 
                                for identifying individual runs for files that fall under an application-algorithm 
                                pair. The output format is an approximation of the file path segment with a few changes.
                                <ol>
                                    <li>
                                        The names of parameters are used instead of parameter values.
                                    </li>
                                    <li>
                                        There is space between every header and separator.
                                    </li>
                                    <li>
                                        For applications and algorithms, the first header (eg: app-im) is replaced by 
                                        the special symbol &ltSTART&gt and the last separator is followed by the 
                                        special symbol &ltEND&gt.
                                    </li>
                                    <li>
                                        For joint sections, if neither a timestamp nor a random id are used, the 
                                        term Nothing appears before whatever separator would follow if something 
                                        were used.
                                    </li>
                                </ol>
                                <b>Application/Algorithm Example:</b> 
                                &ltSTART&gt _ seed_set_size / time_horizon _ &ltEND&gt<br>
                                <b>Joint Example 1:</b> Timestamp _<br>
                                <b>Joint Example 2:</b> Timestamp _ Random ID /<br>
                                <b>Joint Example 3:</b>Nothing /<br>
                                To run this command, run alter_namespace.py from the Code directory and provide 
                                either '-info' or '-8' as the mode indicator. You will also need to provide an application,
                                an algorithm, or both (for information identifying runs that fall under the pair) to indicate 
                                
                            </li>
                            <li>
                                List: The list command is used to print off a list of the names of all registered
                                applications, algorithms, or both. The registered applications and algorithms 
                                are those that will be used when a relevant command is run with '-all' given as the application 
                                and/or algorithm.<br>
                                To run this command, run alter_namespace.py from the Code directory and provide 
                                either '-list' or '-9' as the mode indicator. You will also need to indicate if 
                                you want the applications, algorithms, or both listed. Passing a value of either 
                                'app' or '1' will cause it to list the registered applications. Passing a value of either 
                                'alg' or '2' will cause it to list the registered algorithms. And passing a value of either 
                                'both' or '3' will cause it to list the both the registered applications and the 
                                registered algorithms. <br>
                                <b>Example 1:</b> alter_namespace.py -list app <br>
                                Running this with python will list all registered applications.<br>
                                <b>Example 2:</b> alter_namespace.py -9 3<br>
                                Running this with python will list all registered applications and algorithms.<br>
                            </li>
                        </ol>
                    </p>
                </div>
                <div id="altering_namespace">
                    <h3>Changing Path Configurations</h3>
                    <p>
                        To change the way paths are currently configured and register or unregister applications and 
                        algorithms, you will want to use the interface defined in 'alter_namespace.py'.<br>
                        alter_namespace.py offers the following commands for changing configurations and 
                        registering/unregistering applications and algorithms:<br>
                        <ol>
                            <li></li>
                        </ol>
                    </p>
                </div>
            </div>
            <div id="run_experiments">
                <h2>Details on Running Experiments</h2>
                <p>

                </p>
                <div id="input_files">
                    <h3>Creating Input Files</h3>
                    <div id="handcrafted_input">
                        <h4>Manually Creating Input Files</h4>
                        <p>

                        </p>
                    </div>
                    <div id="generating_input">
                        <h4>Generating Input Files</h4>
                        <div id="generation_file">
                            <h5>Generation Files</h5>
                            <p>

                            </p>
                        </div>
                        <div id="generating">
                            <h5>UI to Generate Input Files</h5>
                            <p>

                            </p>
                        </div>
                    </div>
                </div>
                <div id="running">
                    <h3>UI to Run and Resume Experiments</h3>
                    <p>

                    </p>
                </div>
            </div>
            <div id="misc">
                <h2>Miscellaneous</h2>
                <div id="terminology">
                    <h3>Terminology</h3>
                    <p>
                        In the process of creating the multi-armed bandits experiment system, there was some internal terminology
                        developed and used. Where possible, this documentation will strive to either use clearer terminology and/or 
                        to define these terms in the places they are used. However, in case some instances are missed, the terminology
                        definitions are collected here.
                    </p>
                    <ul style="list-style: circle;">
                        <li>
                            <b>joint</b>:
                            The term 'joint' refers to information, files, etc, that are, in some way, tied to both applications and 
                            algorithms.<br> 
                            In the namespace system, the information chosen to identify an individual run (timestamp, random id) is 
                            configurable on the level of which application is paired with which algorithm. Since it pertains to both, 
                            the configuration information is known as joint information or the joint configuration and files and folder 
                            used to hold this information are also referred to as joint.<br>
                            In the system for looking up parameters, any static values that calculated using information from both the 
                            application and the algorithm are known as joint parameters and are stored and accessed using the global 
                            variable joint_index.
                        </li>
                        <li>
                            <b>namespace</b>: 
                            The term 'namespace' refers to how the file paths of experiment result files are configured. Similarly, 
                            'namespace system' refers to the sub-system that calculates these paths and changes the paths and configurations 
                            for existing and current files, and 'namespace files' refers to files specifying the configurations for different
                            applications, algorithms, and application-algorithm pairs.
                        </li>
                    </ul>
                </div>
                <div id="json_primer">
                    <h3>Primer on JSON Files</h3>
                    <p>
                        JavaScript Object Notation (JSON) is a format for serializing object data (no functions) as text.
                        All system, logging, and input files used by the system use JSON format, so an overview is provided here.
                    </p>
                    <div>
                        <p>Values in JSON are all one of the following datatypes:</p>
                        <ol>
                            <li>
                                <p>
                                    <b>String</b>:
                                    A JSON String functions like a String in most programming languages (sequence of characters surrounded by quotation marks) with one notable rule:
                                    The quotation marks surrounding the sequence of characters MUST be double quotes. So "hello" is a valid JSON String and 'hello' is not.
                                </p>
                            </li>
                            <li>
                                <p>
                                    <b>number</b>:
                                    Numbers are represented in JSON the same way they are represented in most programming languages. Numbers can be in integer or floating point format,
                                    hexadecimal and other formats are not supported.
                                    <br>
                                    <b>Some examples:</b>
                                    <br>
                                    42
                                    <br>
                                    37.0485
                                </p>
                            </li>
                            <li>
                                <p>
                                    <b>boolean</b>:
                                    Boolean values in JSON are represented by the lower-case literals:<br>
                                    true<br>
                                    false<br>
                                </p>
                            </li>
                            <li>
                                <p>
                                    <b>null</b>: 
                                    Null values are represented with the literal 'null'<br>
                                    <b>For instance:</b><br>
                                    "value":null
                                </p>
                            </li>
                            <li>
                                <p>
                                    <b>List</b>:
                                    Lists in JSON are similar to Lists in Python: they consist of a left bracket ([), a right bracket (]), and zero or more comma-separated JSON values
                                    between them.<br>
                                    <b>Example 1:</b><br>
                                    []<br>
                                    <b>Example 2:</b><br>
                                    [true]<br>
                                    <b>Example 3:</b><br>
                                    [false, "hello", null, 42.2, {"greeting":"hola", "age":32}, [45, 38]]
                                </p>
                            </li>
                            <li>
                                <p>
                                    <b>Object</b>:
                                    Objects in JSON are containers for variables, similar to Python dictionaries. They consist of a right curly brace ({), a left curly brace (}),
                                    and zero or more comma-separated JSON variables between them.<br>
                                    <b>Example 1:</b><br>
                                    {}<br>
                                    <b>Example 2:</b><br>
                                    {"alive":true}<br>
                                    <b>Example 3:</b><br>
                                    {"dead":false, "greeting":"hello", "fastest_runner":null, "best_time":42.2, "other":{"greeting":"hola", "age":32}, "friends":["frank", "joe"]}
                                </p>
                            </li>
                        </ol>
                    </div>
                    <p>
                        JSON variables are defined using a JSON String for the variable name, followed by a colon (:) as the assignment operator, and then finally a value that is one
                        of the JSON data types. This is similar to how dictionary items are defined in Python when using an initializer string.
                        <br>
                        <b>For instance:</b> "greetings":["hello","hola","aloha"]
                    </p>
                    <p>
                        JSON files are simple text files (.txt) with the extension changed to '.json'. The content of a JSON file
                        is a JSON object that is not assigned to anything.
                        <br>
                        <b>For instance:</b>
                        <br>
                        <pre>{
    "greeting":"hello"
}
                        </pre>
                        Could be the entire content of a JSON file.
                    </p>
                </div>
                <div id="names">
                    <h3>Application and Algorithm Names</h3>
                    <p>
                        Parts of the documentation mention the use of an 'application name' or an 'algorithm name'.
                        This name should be a string with specific spelling and capitalization used to refer to the application or 
                        algorithm. For example, the influence maximization application has the application name im.<br>
                        This name wil be used within file names and file paths, so it should not contain the basic separator string or 
                        file path break characters and should only contain characters that are valid to use in file paths.
                    </p>
                </div>
                <div id="basic_separator">
                    <h3>Basic Separator</h3>
                    <p>
                        The term 'basic separator' or 'basic_separator' refers to a global String variable 'basic_separator' located in 'Code/Utilities/program_vars.py'.
                        When constructing the file paths for experimental result files, parameters that are not separated by path breaks (making folders) are separated by this 
                        String.<br>
                        At the time of writing, the value of this String is '_' (The underscore character).<br>
                        While it is theoretically possible to change the value of  the basic separator, no systems are currently in place to enact this change automatically.
                        If you wish to change this value, you need to perform the following steps:
                        <ol>
                            <li>Change the value of basic_separator to the new value.</li>
                            <li>Manually replace the previous value with the new one in all locations of all paths for all existing 
                                generated experiment result files.
                            </li>
                            <li>Ensure that no application or algorithm names contain the new basic_separator value. If they do you will need to change the 
                                conflicting names and replace the old names in all relevant locations. Including:
                                <ol>
                                    <li>Application or Algorithm implementation file names.</li>
                                    <li>Parameter file names.</li>
                                    <li>Namespace file names, if a namespace file exists for the application or algorithm in question.</li>
                                    <li>The first item in the "headers" list within the namespace file, if such a file exists.</li>
                                </ol>
                            </li>
                            <li>
                                Ensure that no parameter value used in a path uses the new basic separator value in its string representation.
                                For any that do, you will need to change how the string representation is crafted and change the file path 
                                value of any existing files to match the new representation.
                            </li>
                        </ol>
                    </p>
                </div>
                <div id="unique_params">
                    <h3>Unique Parameters</h3>
                    <p>
                        Input files specifying applications or algorithms have the option to specify a boolean variable 'unique' for every application and algorithm.
                        What that variable does, if set to true, is to specify that every experiment in which the listed application/algorithm configuration 
                        participates should receive a new, deep copy of the parameter dictionary for the configuration. If false, it will save memory by using the same parameter
                        dictionary instance for all experiments in which the application/algorithm participates. This option is available to help avoid side effects if 
                        using the same dictionary instance could cause problems.<br>
                        In cases where this variable does not appear, a default value is used. The default value is defined by the boolean variable 'default_unique_params' 
                        located in 'Code/Utilities/program_vars.py'. At the time of writing, the default value is false.
                        <b>IMPORTANT NOTE:</b> This variable does <b>NOT</b> affect cases where multiple runs are desirable for each instance of the experiment. 
                        Future work on the system may wish to address this shortcoming, but, as a current workaround, designing Applications and Algorithms to 
                        store some initial state for the parameters that is restored when the 'refresh' function is called should work so long as the global variable 
                        'reset' is always set to true in input files.
                    </p>
                </div>
                <div id="unique_instance">
                    <h3>Unique Instance</h3>
                    <p>
                        Input files specifying applications or algorithms have the option to specify a boolean variable 'unique_instance' for every application and algorithm.
                        What that variable does, if set to true, is to specify that every experiment in which the listed application/algorithm configuration 
                        participates should recieve a new Application/Algorithm instance to work with. If false, it will save memory by using the same Application/Algorithm instance 
                        for all experiments in which the application/algorithm participates. This option is available to help avoid side effects if 
                        using the same Application/Algorithm instance could cause problems.<br>
                        In cases where this variable does not appear, a default value is used. The default value is defined by the boolean variable 'default_unique_instance' 
                        located in 'Code/Utilities/program_vars.py'. At the time of writing, the default value is false.
                        <b>IMPORTANT NOTE:</b> This variable does <b>NOT</b> affect cases where multiple runs are desirable for each instance of the experiment. 
                        Future work on the system may wish to address this shortcoming, but, as a current workaround, designing Applications and Algorithms to 
                        store some initial state for the parameters that is restored when the 'refresh' function is called should work so long as the global variable 
                        'reset' is always set to true in input files.
                    </p>
                </div>
                <div>
                    global params
                </div>
                <div>
                    program indices
                </div>
            </div>
        </div>
    </body>
</html>